<html> <HEAD>
<LINK REL=StyleSheet HREF="style.css" TYPE="text/css" MEDIA=screen>
<LINK REL=StyleSheet HREF="style-print.css" TYPE="text/css" MEDIA=print>
</HEAD> <body>


<P>This page is not meant to be a comprehensive and self-sufficient guide to exporting C++ classes into Python using the Orange's machinery. To learn how to export your functions and classes to Python, you should open some Orange's files (the .cpp files that begin with lib_ and cls_) and search for examples, while this page will hopefully help you to understand them. The easiest way to write your interfaces will be to copy and modify Orange's code.</P>

<P>If you are writing extension modules for Python, you by no means have to use Orange's scripts for interfacing. Compile your interface with any tool you want. The only possible complications would arise if you are deriving and exporting new C++ classes from Orange's classes (to those that know something on the topic: Orange uses a slightly extended version of <CODE>PyTypeObject</CODE>, and the derived classes can't return to the original). If need be, ask and we shall provide some more insight and help to overcome them.</P>


<H1>Orange's C++ to Python interface</H1>

<P>Instead of general 3rd party tools (Swig, Sip, PyBoost...) for interfacing between C++ and Python, Orange uses it's own set of tools. (We are working towards making them general, ie also useful for other applications.) These tools (two Python scripts, actually, pyprops and pyxtract) require more manual programming than other tools, but on the other hand, the result is a tighter and nicer coupling of Orange with Python.</P>

<P>In short, to expose a C++ object to Python, we mark the attributes to be exported by a comment line starting with <CODE>//P</CODE>. Besides, we need to either declare which general constructor to use or program a special one, and program the interfaces to those C++ member functions that we want exported. In order for pyxtract to recognize them, the function name should be composed of the class name and method name, separated by an underscore, and followed by a certain keyword. When we simply give the access to unaltered C++ functionality, the interface functions are a few-liners. When we want to make the "Python" version of the function more friendly, eg. allow various types of arguments or fitting the default arguments according to the given, these functions will be longer, but the pay-off is evident. We argue that a few-line function is not more of inconvenience than having to write export declarations (as is the case with Sip at least, I guess), so that's why we do it the way we do it.</P>

<P>To define a non-member function, we write the function itself according to the instructions in Python's manual (see the first chapter of "Extending and Embedding the Python Interpreter") and then mark it with a specific keyword. Pyxtract will recognize the keyword and add it to the list of exported functions.</P>

<P>If you only export non-member function, that is, if you don't intend to declare any new Python classes, you can proceed directly to the section on <A href="#nonmember">exporting non-member functions</A>.</P>


<P>For the rest, here's some more introductory description. Orange's core C++ objects are essentially unaware of Python above them. However, to facilitate easier interface with Python, each Orange class contains a static pointer to a list of its ``properties'' (attributes, in Python terminology). Accessing the object's attributes from Python goes through that list. These lists, however, are general and would be equally useful if we were to interface Orange to some other language (eg Perl) or technology (ActiveX, Corba).</P>

<P>The only exception to the Orange's independency of Python is garbage collection: Orange uses Python's garbage collection for the sake of efficiency and simplicity. Each Orange's pointer (except for the short-term ones) is wrapped into a wrapper of type <CODE>PyObject *</CODE>. Dependency of Orange on Python is not strong - if we wanted to get rid of it, we'd only need to write our own garbage collection (or steal the Python's). <CODE>PyObject *</CODE> is the basic Python's type which stores some garbage collection related stuff, a pointer to the class type (<CODE>PyTypeObject *</CODE>) and the class specific data. The specific data is, in Orange's case, a pointer to the Orange object. Class type is a structure that contains the class name, pointers to function that implement the class special methods (such as indexing, printing, memory allocation, mathematical operations) and class members.</P>

<P>We won't go deeper into explaining <CODE>PyTypeObject</CODE> since this is done in Python documentation. What you need to know is that for each Orange class that is accessible from Python, there is a corresponding <CODE>PyTypeObject</CODE> that defines its methods. For instance, the elements of <CODE>ExampleTable</CODE> (examples) can be accessed through indexing because we defined a C function that gets an index (and the table, of course) and returns the corresponding example, and we've put a pointer to this method into the <CODE>ExampleTable</CODE>'s <CODE>PyTypeObject</CODE>. This is equivalent to overloading the operator [] in C++. Here's the function (with error detection removed for the sake of clarity).

<XMP class=code>
PyObject *ExampleTable_getitem_sq(PyObject *self, int idx)
{
  CAST_TO(TExampleTable, table);
  return Example_FromExampleRef((*table)[idx], EXAMPLE_LOCK(PyOrange_AsExampleTable(self)));
}
</XMP>


Also, <CODE>ExampleTable</CODE> has a method <CODE>sort([list-of-attributes])</CODE>. This is implemented through a C function that gets a list of attributes and calls the C++ class' method <CODE>TExampleTable::sort(const vector&lt;int&gt; order)</CODE>. To illustrate, this is a slightly simplified function (we've removed some flexibility regarding the parameters and the exception handling).

<XMP class=code>
PyObject *ExampleTable_sort(PyObject *self, PyObject *args) PYARGS(METH_VARARGS, "() -> None")
{ 
  CAST_TO(TExampleTable, table);

  if (!args || !PyTuple_Size(args)) {
    table->sort();
    RETURN_NONE;
  }

  TVarList attributes;
  varListFromDomain(PyTuple_GET_ITEM(args, 0), table->domain, attributes, true, true);
  vector<int> order;
  for(TVarList::reverse_iterator vi(attributes.rbegin()), ve(attributes.rend());
      vi!=ve; vi++)
    order.push_back(table->domain->getVarNum(*vi));
        
  table->sort(order);
  RETURN_NONE;
}
</XMP>

<P>Basically, what the function does is it casts the <CODE>PyObject *</CODE> into the corresponding C++ object ("unwrapping"), reads the arguments, calls the C++ functions and returns the result (<CODE>None</CODE>, in this case).</P>

<P>There seem to be a lot of manual work involved in interfacing. Indeed there is, but this is exactly why Orange is so user friendly. The manual control of argument conversion gives a programmer the opportunity to program a function which accepts many different forms of arguments. The above function, for instances, can accept the list where the attributes can be specified by indices, names or descriptors, all corresponding to the <CODE>ExampleTable</CODE> which is being sorted. Inheritance of methods, on the other hand, ensures that only the methods that are truly specific for a class need to be coded.</P>


<P>The part of the interface that is programmed automatically is taken care of by two scripts. <CODE>pyprops.py</CODE> parses all Orange's header files and extracts all the class built-in properties. The result are lists of properties (attributes); nothing needs to be done for the <CODE>ExampleTable</CODE>'s attribute <CODE>domain</CODE> to be visible in Python (OK, except for putting a <CODE>// P</CODE> after its declaration.</P>

<P>The second script is <CODE>pyxtract.py</CODE> is goes through the C++ files that contain the interface functions, such as those above. It recognizes the functions that implement special or member methods and constructs the corresponding <CODE>PyTypeObject</CODE>s. It therefore relieves us from the most boring part of work, but permits us to program things like more intelligent argument or error handling.</P>


<H2>pyprops</H2>

<P>Pyprops scans each hpp file for classes we want to export to Python (or, in general, some other scripting language). Properties can be <CODE>bool</CODE>, <CODE>int</CODE>, <CODE>float</CODE>, <CODE>string</CODE>, <CODE>TValue</CODE> or a wrapped Orange type.</P>

<P>Pyprops' parser is essentially a trivial finite automaton. Class definition needs to look as follows.</P>
<XMP class=code>class [ORANGE_API] &lt;classname&gt; [: public &lt;parentclass&gt; ]
</XMP>

<P>This should be in a single line. To mark the class for export, this should be followed by <CODE>REGISTER_CLASS</CODE> or <CODE>REGISTER_ABSTRACT_CLASS</CODE> before any properties or components are defined. The difference between the two, as far as pyprops is concerned, is that abstract classes don't define the <CODE>clone</CODE> method.</P>

<P>To export a property, it should be defined like this.</P>
<XMP class=code>&lt;type&gt; &lt;name&gt; //P[R|O] [>|+&lt;alias&gt;] &lt;description&gt;</XMP>

<P>Pyprops doesn't check the type and won't object if you use other types than those listed above. Linker will complain about missing symbols, though. <CODE>//P</CODE> signals that we want to export the property. If followed by R or O, the property is read-only or obsolete. The property can also have an alias name; > renames it and + adds an alias. Description is not used at the time, but it is nevertheless a good practice to provide it.</P>

<P>Components are wrapped Orange objects which we don't want the Python programmer to know about. Pyprops prepares a list of components so that the cyclic garbage collector can count them in (and throw them out, if need be). If a class directly or indirectly holds references to any wrapped objects that are neither properties nor components, it will need to declare <CODE>traverse</CODE> and <CODE>clear</CODE> to include them in the garbage collection.</P>

<P>The ppp files that pyprops creates first #include the corresponding hpp file and then declare the necessary definition for each exported file. A list of properties store their names, descriptions, typeid's (RTTI), a class description for the properties' type, the properties' offset and the flags denoting read-only and obsolete properties.</P>

<P>Then comes a list of components' offsets, followed by a definition of classes static field <CODE>st_classDescription</CODE> and a virtual function <CODE>classDescription</CODE> that return a pointer to it. Finally, if the class is not abstract, a virtual function <CODE>clone</CODE> is defined that returns a <CODE>new</CODE> instance of this class initialized, through a copy constructor, with an existing one.</P>

<P>ppp file contains definitions, so it has to be compiled only ones. The most convenient way to do it is to include it in the corresponding cpp file. For instance, domain.ppp is generated from domain.hpp. Various Orange cpp files include domain.hpp, while domain.ppp is included by domain.cpp.</P>


<h2>pyxtract</h2>

<P>Pyxtract job is to detect the functions that define special methods (such as printing, conversion, sequence and arithmetic related operations...) and member functions. Based on what it finds for each specific class, it constructs the corresponding <CODE>PyTypeObject</CODE>s. For the functions to be recognized, they must follow a specific syntax.</P>

<P>There are two basic mechanisms used. Special functions are recognized by their definition (they need to return <CODE>PyObject *</CODE>, <CODE>void</CODE> or <CODE>int</CODE> and their name must be of form &lt;classname&gt;_&lt;functionname&gt;). Member functions, inheritance relations, constants etc. are marked by macros such as <CODE>PYARGS</CODE> in the above definition of <CODE>ExampleTable_sort</CODE>. These macros usually don't do anything, so C++ compiler ignores them - they are just markups for pyxtract.</P>

<H3>Class declaration</H3>

<P>Each class needs to be declared: pyxtract must know from which parent class the class it's derived or, if it's a base class, it must be given a type "derived" from <CODE>PyObject</CODE> which will store the instances of the class (the quotation mark are here because Python is written in C++, so the subclasses are not derived in the C++ sense). It should also know how the class is constructed - it can have a specific constructor, one of the general constructors or no constructor at all.</P>


<P>The class is declared in one of the following ways.
<DL>
<DT><CODE>BASED_ON(Variable, Orange)</CODE></DT>
<DD>This tells pyxtract that <CODE>Variable</CODE> is an abstract class derived from <CODE>Orange</CODE>. The statement is put in C++ code; <CODE>BASED_ON</CODE> is defined as a two-argument macro that does nothing.</DD>

<DT><CODE>C_NAMED(EnumVariable, Variable, "([name=, values=, autoValues=, distributed=, getValueFrom=])")</CODE></DT>
<DD><CODE>EnumVariable</CODE> is derived from <CODE>Variable</CODE>. Pyxtract will also create a constructor which will as an optional argument accept the object's name. The third argument is a string that describes the constructor, eg. gives a list of arguments. IDEs for Python, such as PythonWin, will show this string in a balloon help while the programmer is typing.</DD>

<DT><CODE>C_UNNAMED(RandomGenerator, Orange, "() -> RandomGenerator")</CODE></DT>
<DD>This is similar as <CODE>C_NAMED</CODE>, except the constructor accepts no name. This form is rather rare since all Orange objects can be named.</DD>

<DT><CODE>C_CALL(BayesLearner, Learner, "([examples], [weight=, estimate=] -/-> Classifier")</CODE></DT>
<DD><CODE>BayesLearner</CODE> is derived from <CODE>Learner</CODE>. It will have a peculiar constructor. It will, as usual, first construct an instance of <CODE>BayesLearner</CODE>. If no arguments are given (except for, possibly, keyword arguments), it will return the constructed instance. Otherwise, it will call the <CODE>Learner</CODE>'s call operator and return its result instead of <CODE>BayesLearner</CODE>.</CODE>

<DT><CODE>C_CALL3(MakeRandomIndices2, MakeRandomIndices2, MakeRandomIndices, "[n | gen [, p0]], [p0=, stratified=, randseed=] -/-> [int]")</CODE></DT>
<DD><CODE>MakeRandomIndices2</CODE> is derived from <CODE>MakeRandomIndices</CODE> (the third argument). For a contrast from the above, the corresponding constructor won't call <CODE>MakeRandomIndices</CODE> call operator, but the call operator of <CODE>MakeRandomIndices2</CODE> (the second argument). This constructor is often used when the parent class doesn't provide a suitable call operator.</DD>

<DT><CODE>HIDDEN(TreeStopCriteria_Python, TreeStopCriteria)</CODE></DT>
<DD><CODE>TreeStopCriteria_Python</CODE> is derived from <CODE>TreeStopCriteria</CODE>, but we would like to hide this class from the user. We use this definition when it is elegant for us to have some intermediate class or a class that implements some specific functionality, but don't want to bother the user with it. The class is not completely hidden - the user can reach it through the <CODE>type</CODE> operator on an instance of it. This is thus very similar to a <CODE>BASED_ON</CODE>.</DD>

<DT><CODE>DATASTRUCTURE(Orange, TPyOrange, orange_dict)</CODE></DT>
<DD>This is for the base classes. <CODE>Orange</CODE> has no parent class. The C++ structure that stores it is <CODE>TPyOrange</CODE>; <CODE>TPyOrange</CODE> is essentially <CODE>PyObject</CODE> (this is a rule: the structure always has to be based on <CODE>PyObject</CODE>!) but with several additional fields, among them a pointer to an instance of <CODE>TOrange</CODE> (the C++ base class for all Orange's classes). <CODE>orange_dict</CODE> is a name of <CODE>TPyOrange</CODE>'s field that points to a Python dictionary; when you have an instance <CODE>bayesClassifier</CODE> and you type, in Python, <CODE>bayesClassifier.someMyData=15</CODE>, this gets stored in <CODE>orange_dict</CODE>. The actual mechanism behind this is rather complicated and you most probably won't need to use it. If you happen to need to define a class with <CODE>DATASTRUCTURE</CODE>, you can simply omit the last argument by giving a 0 instead.</DD>

<DT><CODE>PyObject *ClassifierByLookupTable1_new(PyTypeObject *type, PyObject *args, PyObject *) BASED_ON(ClassifierByLookupTable, "(class-descriptor, descriptor)")</CODE></DT>
<DD><CODE>ClassifierByLookupTable1_new</CODE> has a specific constructor. The general ones above couldn't be used since the constructor need to have some arguments or for some other reason (eg. the user doesn't need to specify the arguments, but the C++ constructor requires them, so this interface function will provide the defaults). The constructor function needs to be like above (ie. &lt;classname&gt;_new), followed by a <CODE>BASED_ON</CODE> macro giving the parent class and the comment. The declaration must be written in a single line. Just for the illustration, the (simplified, no error handling) constructor looks like this
<XMP class=code>
PyObject *ClassifierByLookupTable1_new(PyTypeObject *type, PyObject *args, PyObject *) BASED_ON(ClassifierByLookupTable, "(class-descriptor, descriptor)")
{ 
  PyTRY
    PVariable vcl, vvl;
    PyObject *pyvlist = NULL, *pydlist = NULL;
    if (!PyArg_ParseTuple(args, "O&O&|OO", cc_Variable, &vcl,
                          cc_Variable, &vvl, &pyvlist, &pydlist))
      PYERROR(PyExc_TypeError,
              "invalid parameter; two variables and, optionally, ValueList and DistributionList expected",
               NULL);

    TClassifierByLookupTable1 *cblt = mlnew TClassifierByLookupTable1(vcl, vvl);
    return initializeTables(pyvlist, pydlist, cblt) ? WrapNewOrange(cblt, type) : NULL;
  PyCATCH
}
</XMP>

Function parses the arguments by calling <CODE>PyArg_ParseTuple</CODE>, constructs an instance of <CODE>ClassifierByLookupTable1</CODE>, initializes it and returns either the constructed object or NULL which signifies an error. <CODE>PyTRY</CODE> and <CODE>PyCATCH</CODE> catch the possible Orange's exception and turn them into Python exceptions.</DD>
</DL>
</P>

<P>Even if the class is defined by <CODE>DATASTRUCTURE</CODE>, you can still specify a different constructor, most probably the last form of it (the <CODE>_new</CODE> function). In this case, specify a keyword <CODE>ROOT</CODE> as a parent and pyxtract will understand that this is the base class.</P>

<P>Object construction in Python is divided between two methods. The constructors we discussed above construct the essential part of the object - they allocate the necessary memory and initialize the fields far enough that the object is valid to enter the garbage collection. The second part is handled by the <CODE>init</CODE> method. It is, however, not forbidden to organize the things so that <CODE>new</CODE> does all the job. This is also the case in Orange. The only task left for <CODE>init</CODE> is to set any attributes that user gave as the keyword arguments to the constructor.</P>

<P>For instance, Python's statement <CODE>orange.EnumVariable("a", values=["a", "b", "c"])</CODE> is executed so that <CODE>new</CODE> constructs the variable and gives it the name, while <CODE>init</CODE> sets the <CODE>values</CODE> field. You don't need to do anything about it.</P>

<P>The <CODE>new</CODE> operator, however, sometimes also accepts keyword arguments. For instance, when constructing an <CODE>ExampleTable</CODE> by reading the data from file, you can specify a domain (using keyword argument <CODE>domain</CODE>), a list of attributes to reuse if possible (<CODE>use</CODE>), you can tell it not to reuse the stored domain or not to store the newly constructed domain (<CODE>dontCheckStored</CODE>, <CODE>dontStore</CODE>). After the <CODE>ExampleTable</CODE> is constructed, <CODE>init</CODE> is called to set the attributes. To tell it to ignore the keyword arguments that the constructor might (or had) used, we write the following.

<XMP class=code>
CONSTRUCTOR_KEYWORDS(ExampleTable, "domain use useMetas dontCheckStored dontStore filterMetas")
</XMP>

<P><CODE>init</CODE> will ignore all the keywords from the list.</P>

<P>Talking about attributes, here's another macro. You know you can assign arbitrary attributes to Orange classes. If you do it directly, eg. <CODE>ba.myAttribute = 12</CODE>, you will get a warning (you should use the object's method <CODE>setattr(name, value)</CODE> to avoid it). Some objects have some attributes that cannot be implemented in C++ code, yet they are usual and useful. For instance, <CODE>Graph</CODE> has attributes <CODE>objects</CODE>, <CODE>forceMapping</CODE> and <CODE>returnIndices</CODE>; if you take a look at the documentation on <CODE>Graph</CODE>, you will see why these cannot be implemented in C++. Yet, since these attributes are so common, we don't want to give warnings. We achieve this by
</P>

<XMP class=code>
RECOGNIZED_ATTRIBUTES(Graph, "objects forceMapping returnIndices")
</XMP>

<P>How do these things function? Well, it is not hard to imagine: pyxtract catches all such exceptions and stores the corresponding lists for each particular class. The <CODE>init</CODE> constructor then checks the list prior to setting attributes and the method for setting attributes that issues warnings for unknown attributes checks it prior to complaining.</P>


<H3>Special methods</H3>

<P>Special methods are class built-in methods. They essentially define the type: if it, for instance, supports multiplication, it should define the operator that gets the object itself and another object and return the product (or throw an exception). If it allows for indexing, it defines an operator that gets the object itself and the index and returns the element. These operators are low-level; most can be called from Python scripts but they are also internally by Python. For instance, if <CODE>table</CODE> is an <CODE>ExampleTable</CODE>, then <CODE>for e in table:</CODE> or <CODE>reduce(f, table)</CODE> will both work by calling the indexing operator for each table's element.</P>

<P>We shall here avoid the further discussion of this since the topic is adequately described in Python manuals (see "Extending and Embedding the Python Interpreter", chapter 2, "Defining New Types").</P>

<P>To define a method for Orange class, you need to define a function named, <CODE>&lt;classname&gt;_&lt;methodname&gt;</CODE>; the function should return either <CODE>PyObject *</CODE>, <CODE>int</CODE> or <CODE>void</CODE>. The function's head has to be written in a single line. Regarding the arguments and the result, it should conform to Python's specifications. Pyxtract will detect the methods and set the pointers in <CODE>PyTypeObject</CODE> correspondingly.</P>

<P>Here's a list of methods: the left column represents a method name that triggers pyxtract (these names generally correspond to special method names of Python classes as a Python programmer sees them) and the second next is the name of the field in <CODE>PyTypeObject</CODE> or subjugated structures. See Python documentation for description of functions arguments and results. Not all methods can be directly defined; for those that can't, it is because we either use an alternative method (eg. <CODE>setattro</CODE> instead of <CODE>setattr</CODE>) or pyxtract gets or computes the data from this field otherwise. If you miss something, just modify pyxtract...</P>

<H4>General methods</H4>

<TABLE>
<TR VALIGN=TOP><TD><B>pyxtract</B></TD><TD><B>PyTypeObject<B></TD><TD></TD></TR>
<TR VALIGN=TOP><TD><CODE>dealloc</CODE></TD><TD><CODE>tp_dealloc<CODE></TD><TD>Frees the memory occupied by the object. You will need to define this for the classes with a new <CODE>DATASTRUCTURE</CODE>; if you only derive a class from some Orange class, this has been taken care of. If you have a brand new object, copy the code of one of Orange's deallocators.</TD></TR>

<TR VALIGN=TOP><TD>.<CODE>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</CODE></TD><TD><CODE>tp_print</CODE></TD><TD>This function can't be redefined as it seem to crash Python (due to difference in compilers?!)</TR>
<TR VALIGN=TOP><TD>.</TD><TD><CODE>tp_getattr</CODE></TD><TD>Can't be redefined since we use <CODE>tp_getattro</CODE> instead.</TD></TR>
<TR VALIGN=TOP><TD>.</TD><TD><CODE>tp_setattr</CODE></TD><TD>Can't be redefined since we use <CODE>tp_setattro</CODE> instead.</TD></TR>

<TR><TD><CODE>cmp</CODE></TD><TD><CODE>tp_compare</CODE></TD></TR>
<TR><TD><CODE>repr</CODE></TD><TD><CODE>tp_repr</CODE></TD></TR>

<TR VALIGN=TOP><TD>.</TD><TD><CODE>as_number</CODE></TD><TD>(don't care about it; if you give any of the methods from the number interface, pyxtract will initialize this field)</TD></TR>

<TR VALIGN=TOP><TD>.</TD><TD><CODE>as_sequence</CODE></TD><TD>(don't care about it; if you give any of the methods from the sequence interface, pyxtract will initialize this field)</TD></TR>

<TR VALIGN=TOP><TD>.</TD><TD><CODE>as_mapping</CODE></TD><TD>(don't care about it; if you give any of the methods from the mapping interface, pyxtract will initialize this field)</TD></TR>

<TR VALIGN=TOP><TD><CODE>hash</CODE></TD><TD><CODE>tp_hash</CODE></TD><TD>Class <CODE>Orange</CODE> computed a hash value from the pointer; you don't need to overload it if your object inherits the function. If you write an independent class, just copy the code.</TD></TR>

<TR><TD><CODE>call</CODE></TD><TD><CODE>tp_call</CODE></TD></TR>

<TR><TD><CODE>call</CODE></TD><TD><CODE>tp_call</CODE></TD></TR>
<TR><TD><CODE>str</CODE></TD><TD><CODE>tp_str</CODE></TD></TR>
<TR><TD><CODE>getattr</CODE></TD><TD><CODE>tp_getattro</CODE></TD></TR>
<TR><TD><CODE>setattr</CODE></TD><TD><CODE>tp_setattro</CODE></TD></TR>

<TR VALIGN=TOP><TD><CODE>.</CODE></TD><TD><CODE>tp_as_buffer</CODE></TD><TD>Pyxtract doesn't support the buffer protocol.</TD></TR>
<TR><TD><CODE>.</CODE></TD><TD><CODE>tp_flags</CODE></TD><TD>Flags are set by pyxtract.</TD></TR>
<TR VALIGN=TOP><TD><CODE>.</CODE></TD><TD><CODE>tp_doc</CODE></TD><TD>Documentation is read from the constructor definition (see above).</TR>

<TR VALIGN=TOP><TD><CODE>traverse</CODE></TD><TD><CODE>tp_traverse</CODE></TD><TD>Traverse is tricky (as is garbage collection in general). There's something on it in a comment in root.hpp; besides that, study the examples. In general, if a wrapped member is exported to Python (just as, for instance, <CODE>Classifier</CODE> contains a <CODE>Variable</CODE> named <CODE>classVar</CODE>), you don't need to care about it. You should manually take care of any wrapped objects not exported to Python).
</TR>

<TR><TD><CODE>clear</CODE></TD><TD><CODE>tp_clear</CODE></TD></TR>
<TR><TD><CODE>richcmp</CODE></TD><TD><CODE>tp_richcmp</CODE></TD></TR>
<TR><TD><CODE>.</CODE></TD><TD><CODE>tp_weaklistoffset</CODE></TD></TR>
<TR><TD><CODE>iter</CODE></TD><TD><CODE>tp_iter</CODE></TD></TR>
<TR><TD><CODE>iternext</CODE></TD><TD><CODE>tp_iternext</CODE></TD></TR>
<TR><TD><CODE>.</CODE></TD><TD><CODE>tp_methods</CODE></TD><TD>Set by pyxtract if any methods are given.</TR>
<TR><TD><CODE>.</CODE></TD><TD><CODE>tp_members</CODE></TD></TR>
<TR><TD><CODE>.</CODE></TD><TD><CODE>getset</CODE></TD><TD>Pyxtract initialized this by a pointer to manually written getters/setters (see below).</TD></TR>
<TR><TD><CODE>.</CODE></TD><TD><CODE>tp_base</CODE></TD><TD>Set by pyxtract to a class specified in constructor (see above).</TR>
<TR><TD><CODE>.</CODE></TD><TD><CODE>tp_dict</CODE></TD><TD>Used for class constants (eg. <CODE>Classifier.GetBoth</CODE></TD></TR>
<TR><TD><CODE>.</CODE></TD><TD><CODE>tp_descrget</CODE></TD></TR>
<TR><TD><CODE>.</CODE></TD><TD><CODE>tp_descrset</CODE></TD></TR>
<TR VALIGN=TOP><TD><CODE>.</CODE></TD><TD><CODE>tp_dictoffset</CODE></TD><TD>Set by pyxtract to the field given in <CODE>DATASTRUCTURE</CODE> (if there is any).</TR>

<TR><TD><CODE>init</CODE></TD><TD><CODE>tp_init</CODE></TD></TR>
<TR><TD><CODE>.</CODE></TD><TD><CODE>tp_alloc</CODE></TD><TD>Set to <CODE>PyType_GenericAlloc</CODE></TD></TR>
<TR><TD><CODE>new</CODE></TD><TD><CODE>tp_new</CODE></TD></TR>
<TR><TD><CODE>.</CODE></TD><TD><CODE>tp_free</CODE></TD><TD>Set to <CODE>_PyObject_GC_Del</CODE></TD></TR>
<TR><TD><CODE>.</CODE></TD><TD><CODE>tp_is_gc</CODE></TD></TR>
<TR><TD><CODE>.</CODE></TD><TD><CODE>tp_bases</CODE></TD></TR>
<TR><TD><CODE>.</CODE></TD><TD><CODE>tp_mro</CODE></TD></TR>
<TR><TD><CODE>.</CODE></TD><TD><CODE>tp_cache</CODE></TD></TR>
<TR><TD><CODE>.</CODE></TD><TD><CODE>tp_subclasses</CODE></TD></TR>
<TR><TD><CODE>.</CODE></TD><TD><CODE>tp_weaklist</CODE></TD></TR>
</TABLE>

<H4>Numeric protocol</H4>

<TABLE>
<TR><TD><CODE>add</CODE></TD><TD width=20px></TD><TD><CODE>nb_add</CODE></TD>
<TD width=30px></TD>
<TD><CODE>pow</CODE></TD><TD width=20px></TD><TD><CODE>nb_power</CODE></TD>
<TD width=30px></TD>
<TD><CODE>lshift</CODE></TD><TD width=20px></TD><TD><CODE>nb_lshift</CODE></TD>
<TD width=30px></TD>
<TD><CODE>int</CODE></TD><TD width=20px></TD><TD><CODE>nb_int</CODE></TD>
</TR>

<TR><TD><CODE>sub</CODE></TD><TD></TD><TD><CODE>nb_subtract</CODE></TD>
<TD></TD>
<TD><CODE>neg</CODE></TD><TD></TD><TD><CODE>nb_negative</CODE></TD>
<TD></TD>
<TD><CODE>rshift</CODE></TD><TD></TD><TD><CODE>nb_rshift</CODE></TD>
<TD></TD>
<TD><CODE>long</CODE></TD><TD></TD><TD><CODE>nb_long</CODE></TD>
</TR>

<TR><TD><CODE>mul</CODE></TD><TD></TD><TD><CODE>nb_multiply</CODE></TD>
<TD></TD>
<TD><CODE>pos</CODE></TD><TD></TD><TD><CODE>nb_positive</CODE></TD>
<TD></TD>
<TD><CODE>and</CODE></TD><TD></TD><TD><CODE>nb_and</CODE></TD>
<TD></TD>
<TD><CODE>float</CODE></TD><TD></TD><TD><CODE>nb_float</CODE></TD>
</TR>

<TR><TD><CODE>div</CODE></TD><TD></TD><TD><CODE>nb_divide</CODE></TD>
<TD></TD>
<TD><CODE>abs</CODE></TD><TD></TD><TD><CODE>nb_absolute</CODE></TD>
<TD></TD>
<TD><CODE>or</CODE></TD><TD></TD><TD><CODE>nb_or</CODE></TD>
<TD></TD>
<TD><CODE>oct</CODE></TD><TD></TD><TD><CODE>nb_oct</CODE></TD>
</TR>

<TR><TD><CODE>mod</CODE></TD><TD></TD><TD><CODE>nb_remainder</CODE></TD>
<TD></TD>
<TD><CODE>nonzero</CODE></TD><TD></TD><TD><CODE>nb_nonzero</CODE></TD>
<TD></TD>
<TD><CODE>coerce</CODE></TD><TD></TD><TD><CODE>nb_coerce</CODE></TD>
<TD></TD>
<TD><CODE>hex</CODE></TD><TD></TD><TD><CODE>nb_hex</CODE></TD>
</TR>

<TR><TD><CODE>divmod</CODE></TD><TD></TD><TD><CODE>nb_divmod</CODE></TD>
<TD></TD>
<TD><CODE>inv</CODE></TD><TD></TD><TD><CODE>nb_invert</CODE></TD>
</TR>
</TABLE>


<H4>Sequence protocol</H4>

<TABLE>
<TR><TD><CODE>len_sq</CODE></TD><TD width=20px></TD><TD><CODE>sq_length</CODE></TD>
<TD width=30px></TD>
<TD><CODE>getslice</CODE></TD><TD width=20px></TD><TD><CODE>sq_slice</CODE></TD>
</TR>

<TR><TD><CODE>concat</CODE></TD><TD></TD><TD><CODE>sq_concat</CODE></TD>
<TD></TD>
<TD><CODE>setitem_sq</CODE></TD><TD></TD><TD><CODE>sq_ass_item</CODE></TD>
</TR>

<TR><TD><CODE>repeat</CODE></TD><TD></TD><TD><CODE>sq_slice</CODE></TD>
<TD></TD>
<TD><CODE>setslice</CODE></TD><TD></TD><TD><CODE>sq_ass_slice</CODE></TD>
</TR>

<TR><TD><CODE>getitem_sq</CODE></TD><TD></TD><TD><CODE>sq_item</CODE></TD>
<TD></TD>
<TD><CODE>contains</CODE></TD><TD></TD><TD><CODE>sq_contains</CODE></TD>
</TR>
</TABLE>

<H4>Mapping protocol</H4>

<TABLE>
<TR><TD><CODE>len</CODE></TD><TD width=20px></TD><TD><CODE>mp_length</CODE></TD>
</TR>
<TR><TD><CODE>getitem</CODE></TD><TD width=20px></TD><TD><CODE>mp_subscript</CODE></TD>
</TR>
<TR><TD><CODE>setitem</CODE></TD><TD width=20px></TD><TD><CODE>mp_ass_subscript</CODE></TD>
</TR>
</TABLE>

<P>For example, here's what gets called when you want to know the length of an example table.</P>
<XMP class=code>
int ExampleTable_len_sq(PyObject *self) 
{ PyTRY
    return SELF_AS(TExampleGenerator).numberOfExamples();
  PyCATCH_1
}
</XMP>

<P><CODE>PyTRY</CODE> and <CODE>PyCATCH</CODE> take care of C++ exceptions. <CODE>SELF_AS</CODE> is a macro for casting, ie unwrapping the points (this is an alternative to <CODE>CAST_TO</CODE> you've seen earlier).</P>


<H3>Getting and Setting Class Attributes</H3>

<P>Exporting of most of C++ class fields is already taken care by the lists that are compiled by pyprops. There are only a few cases in whole Orange where we needed to manually write specific handlers for setting and getting the attributes. This need to be done if setting needs some special processing or when simulating an attribute that does not exist in the underlying C++ class.</P>

<P>An example for this is class <CODE>HierarchicalCluster</CODE>. It contains results of a general, not necessarily binary clustering, so each node in the tree has a list <CODE>branches</CODE> with all the node's children. Yet, as the usual clustering is binary, it would be nice if the node would also support attributes <CODE>left</CODE> and <CODE>right</CODE>. They are not present in C++, but we can write a function that check the number of branches; if there are none, it returns <CODE>None</CODE>, if there are more than two, it complains, while otherwise it returns the first branch.</P>

<XMP class=code>
PyObject *HierarchicalCluster_get_left(PyObject *self)
{ 
  PyTRY
    CAST_TO(THierarchicalCluster, cluster);

    if (!cluster->branches)
      RETURN_NONE

    if (cluster->branches->size() > 2)
      PYERROR(PyExc_AttributeError,
              "'left' not defined (cluster has more than two subclusters)",
              NULL);

    return WrapOrange(cluster->branches->front());
  PyCATCH
}
</XMP>

<P>As you can see from the example, the function needs to accept a <CODE>PyObject *</CODE> (the object it<CODE>self</CODE>) and return a <CODE>PyObject *</CODE> (the attribute value). The function name needs to be <CODE>&lt;classname&gt;_get_&lt;attributename&gt;</CODE>. Setting an attribute is similar; function name should be <CODE>&lt;classname&gt;_set_&lt;attributename&gt;</CODE>, it should accept two Python objects (the object and the attribute value) and return an <CODE>int</CODE>, where 0 signifies success and -1 a failure.</P>

<P>If you define only one of the two handlers, you'll get a read-only or write-only attribute.</P>


<H3>Member functions</H3>

<P>You've already seen an example of a member function - the <CODE>ExampleTable</CODE>'s method <CODE>sort</CODE>. The general template is <CODE>PyObject *&lt;classname&gt;_&lt;methodname&gt;(&lt;arguments&gt;) PYARGS(&lt;arguments-keyword&gt;, &lt;documentation-string&gt;)</CODE>. In the case of the <CODE>ExampleTable</CODE>'s <CODE>sort</CODE>, this looks like this.</P>

<XMP class=code>
PyObject *ExampleTable_sort(PyObject *self, PyObject *args) PYARGS(METH_VARARGS, "() -> None")
</XMP>

<P>Argument type can be any of the usual Python constants stating the number and the kind of arguments, such as <CODE>METH_VARARGS</CODE> or <CODE>METH_O</CODE> - this constant get copied to the corresponding list (browse Python documentation for <CODE>PyMethodDef</CODE>).</P>

<P>If you want more examples, just search Orange's files for the keyword <CODE>PYARGS</CODE>.</P>


<H3>Class constants</H3>

<P>This 
<P>Orange classes, as seen from Python, can also have constants, such as <CODE>orange.Classifier.GetBoth</CODE>. Classifier's <CODE>GetBoth</CODE> is visible as a member of the class, the derived classes and all their instances (eg. <CODE>BayesClassifier.GetBoth</CODE> and <CODE>bayes.GetBoth</CODE>).</P>

<P>There are several ways to define such constants. If they are simple integers or floats, you can use <CODE>PYCLASSCONSTANT_INT</CODE> or <CODE>PYCLASSCONSTANT_FLOAT</CODE>, like in
<XMP class=code>PYCLASSCONSTANT_INT(Classifier, GetBoth, 2)</XMP>
You can also use the enums from the class, like 
<XMP class=code>PYCLASSCONSTANT_INT(C45TreeNode, Leaf, TC45TreeNode::Leaf)</XMP>
Pyxtract will convert the given constant to a Python object (using <CODE>PyInt_FromLong</CODE> or <CODE>PyFloat_FromDouble></CODE>).</P>

<P>When the constant is an object of some other type, use <CODE>PYCLASSCONSTANT</CODE>. In this form (not used in Orange yet), the third argument can be either an instance of <CODE>PyObject *</CODE> or a function call. In either case, the object or function must be known at the point where the pyxtract generated file is included.</P>


<A name="nonmember">
<H3>Non-member functions and constants</H3>

<P>Most Orange's functions are members of classes. About the only often used exception to this is <CODE>orange.newmetaid</CODE> which returns a new ID for a meta attribute. These functions are defined in the same way as member function except that the function name doesn't have the class name (and the underscore - that's how pyxtract distinguishes between the two). Here's the <CODE>newmetaid</CODE> function.</P>

<XMP class=code>PyObject *newmetaid(PyObject *, PyObject *) PYARGS(0,"() -> int")
{ PyTRY
    return PyInt_FromLong(getMetaID()); 
  PyCATCH
}
</XMP>

<P>Orange also defines some non-member constants. These are defined in a similar fashion as the class constants. <CODE>PYCONSTANT_INT(&lt;constant-name&gt;, &lt;integer&gt;)</CODE> defines an integer constant and <CODE>PYCONSTANT_FLOAT</CODE> would be used for a continuous one. <CODE>PYCONSTANT</CODE> is used for objects of other types, as the below example that defines an (obsolete) constant <CODE>MeasureAttribute_splitGain</CODE> shows.</P>

<XMP class=code>PYCONSTANT(MeasureAttribute_splitGain, (PyObject *)&PyOrMeasureAttribute_gainRatio_Type)
</XMP>

<P>Class constants from the previous chapter are put in a pyxtract generated file that is included at the end of the file in which the constant definitions and the corresponding classes are. Global constant modules are included in an other file, far away from their actual definitions. For this reason, <CODE>PYCONSTANT</CODE> cannot reference any functions (the above example is an exception - all class types are declared in this same file and are thus available at the moment the above code is used). Therefore, if the constant is defined by a function call, you need to use another keyword, <CODE>PYCONSTANTFUNC</CODE>:</P>

<XMP class=code>PYCONSTANTFUNC(globalRandom, stdRandomGenerator)
</XMP>

<P>Pyxtract will generate a code which will, prior to calling <CODE>stdRandomGenerator</CODE>, declare it as a function with no arguments that returns <CODE>PyObject *</CODE>. Of course, you will have to define the function somewhere in your code, like this:</P>

<XMP class=code>PyObject *stdRandomGenerator()
{ return WrapOrange(globalRandom); }
</XMP>

<P>Another example are <CODE>VarTypes</CODE>. You've probably already used <CODE>orange.VarTypes.Discrete</CODE> and <CODE>orange.VarTypes.Continuous</CODE> to check an attribute's type. <CODE>VarTypes</CODE> is a tiny module inside Orange that contains nothing but five constants, representing various attribute types. From pyxtract perspective, <CODE>VarTypes</CODE> is a constant. Here's the complete definition.</P>

<XMP class=code>PyObject *VarTypes()
{ PyObject *vartypes=PyModule_New("VarTypes");
  PyModule_AddIntConstant(vartypes, "None", (int)TValue::NONE);
  PyModule_AddIntConstant(vartypes, "Discrete", (int)TValue::INTVAR);
  PyModule_AddIntConstant(vartypes, "Continuous", (int)TValue::FLOATVAR);
  PyModule_AddIntConstant(vartypes, "Other", (int)TValue::FLOATVAR+1);
  PyModule_AddIntConstant(vartypes, "String", (int)STRINGVAR);
  return vartypes;
}

PYCONSTANTFUNC(VarTypes, VarTypes)
</XMP>

<P>If you want to understand the constants completely, check the Orange's pyxtract generated file initialization.px.</P>



<H3>How does it all fit together</H3>

<P>This part of the text's main purpose is to remind the pyxtract author of the structure of the files pyxtract creates. (I hate it when I don't know how my programs work :-) If you think you can profit from reading it, you're welcome.</P>

<H4>File specific px files</H4>

<P>For each compiled cpp file, pyxtract creates a px file of the same name. The file starts with externs declaring the base classes for the classes whose types are defined later on.</P>

<P>Then follow class type definitions.
<UL>
<LI>Method definitions (<CODE>PyMethodDef</CODE>). Nothing exotic here, just a table with the member functions that is pointed to by <CODE>tp_methods</CODE> of the <CODE>PyTypeObject</CODE>.</LI>

<LI>GetSet definitions (<CODE>PyGetSetDef</CODE>). Similar to methods, a list to be pointed to by <CODE>tp_getset</CODE>, which includes the attributes for which special handlers were written.</LI>

<LI>Definitions of doc strings for call operator and constructor.</LI>

<LI>Constants. If the class has any constants, there will be a function named <CODE>void &lt;class-name&gt;_addConstants()</CODE>. The function will create a class dictionary in the type's <CODE>tp_dict</CODE>, if there is none yet. Then it will store the constants in it. The functions is called at the module initialization, file initialization.px.</LI>

<LI>Constructors. If the class uses generic constructors (ie, if it's defined by <CODE>C_UNNAMED</CODE>, <CODE>C_NAMED</CODE>, <CODE>C_CALL</CODE> or <CODE>C_CALL3</CODE>), they will need to call a default object constructor, like the below one for <CODE>FloatVariable</CODE>. <FONT color=red>(This supposes the object is derived from <CODE>TOrange</CODE>! We will need to get rid of this we want pyxtract to be more general. Maybe an additional argument in <CODE>DATASTRUCTURE</CODE>?)</FONT>
<XMP class=code>POrange FloatVariable_default_constructor(PyTypeObject *type)
{ return POrange(mlnew TFloatVariable(), type); }
</XMP>
If the class is abstract, pyxtract defines a constructor that will call <CODE>PyOrType_GenericAbstract</CODE>. <CODE>PyOrType_GenericAbstract</CODE> checks the type that the caller wishes to construct; if it is a type derived from this type, it permits it, otherwise it complains that the class is abstract.</P></LI>

<LI>Aliases. A list of renamed attributes.</LI>

<LI>Structures for general function (<CODE>PyTypeObject</CODE>) and the numeric, sequence and mapping protocols. <CODE>PyTypeObject</CODE> is named <CODE>PyOr&lt;classname&gt;_Type_inh</CODE>.</LI>

<LI>Definition of conversion functions. This is done by macro <CODE>DEFINE_cc(&lt;classname&gt;)</CODE> which defines <CODE>int ccn_&lt;classname&gt;(PyObject *obj, void *ptr)</CODE> - functions that can be used in <CODE>PyArg_ParseTuple</CODE> for converting an argument (given as <CODE>PyObject *</CODE> to an instance of <CODE>&lt;classname&gt;</CODE>. Nothing needs to be programmed for the conversion, it is just a cast: <CODE>*(GCPtr< T##type > *)(ptr) = PyOrange_As##type(obj);</CODE>). The difference between <CODE>cc</CODE> and <CODE>ccn</CODE> is that the latter accepts null pointers.</LI>

<LI><CODE>TOrangeType</CODE>. Although <CODE>PyTypeObject</CODE> is a regular Python object, it unfortunately isn't possible to derive new objects from it. Obviously the developers of Python didn't think anyone would need it, and this part of Python's code is messy enough even without it. Orange nevertheless uses a type <CODE>TOrangeType</CODE> that begins with <CODE>PyTypeObject</CODE> (essentially inheriting it). The new definition also includes the RTTI used for wrapping (this way Orange nows which C++ class corresponds to which Python class), a pointer to the default constructor (used by generic constructors), a pointer to list of constructor keywords (<CODE>CONSTRUCTOR_KEYWORDS</CODE>, keyword arguments that should be ignored in a later call to <CODE>init</CODE>) and recognized attributes (<CODE>RECOGNIZED_ATTRIBUTES</CODE>, attributes that don't yield warnings when set), a list of aliases, and pointers to <CODE>cc_</CODE> and <CODE>ccn_</CODE> functions. The latter are not used by Orange, since it can call the converters directly. They are here because <CODE>TOrangeType</CODE> is exported in a DLL while <CODE>cc_</CODE> and <CODE>ccn_</CODE> are not (for the sake of limiting the number of exported symbols).</LI>
</UL>

<H4>initialization.px</H4>

<P>Initialization.px defines the global module stuff.</P>

<P>First, here is a list of all <CODE>TOrangeTypes</CODE>. The list is used for checking whether some Python object is of Orange's type or derived from one, for finding a Python class corresponding to a C++ class (based on C++'s RTTI). Orange also exports the list as <CODE>orange._orangeClasses</CODE>; this is a <CODE>PyCObject</CODE> so it can only be used by other Python extensions written in C.</P>

<P>Then come declarations of all non-member functions, followed by a <CODE>PyMethodDef</CODE> structure with them.</P>

<P>Finally, here are declarations of functions that return manually constructed constants (eg <CODE>VarTypes</CODE>) and declarations of functions that add class constants (eg <CODE>Classifier_addConstants</CODE>). The latter functions were generated by pyxtract and reside in the individual px files. Then follows a function that calls all the constant related functions declared above. This function also adds all class types to the Orange module. <FONT COLOR=RED>Why not in a loop over <CODE>orangeClasses</CODE>?</FONT></P>

<P>The main module now only needs to call <CODE>addConstants</CODE>.</P>

<H4>externs.px</H4>

<P>Externs.px declares symbols for all Orange classes, for instance</P>
<XMP class=code>extern ORANGE_API TOrangeType PyOrDomain_Type;
#define PyOrDomain_Check(op) PyObject_TypeCheck(op, (PyTypeObject *)&PyOrDomain_Type)
int cc_Domain(PyObject *, void *);
int ccn_Domain(PyObject *, void *);
#define PyOrange_AsDomain(op) (GCPtr< TDomain >(PyOrange_AS_Orange(op)))
</XMP>
</P>


<H2>Where to include?</H2>

<P>As already mentioned, ppp files should be included (at the beginning) of the corresponding cpp files, instead of the hpp file. For instance, domain.ppp is included in domain.cpp. Each ppp should be compiled only once, all other files needing the definition of <CODE>TDomain</CODE> should still include domain.hpp as usual.</P>

<P>File-specific px files are included in the corresponding cpp files. lib_kernel.px is included at the end of lib_kernel.cpp, from which it was generated. initialization.px should preferably be included in the file that initializes the module (function <CODE>initorange</CODE> needs to call <CODE>addConstants</CODE>, which is declared in initialization.px. These px files contain definitions and must be compiled only once. externs.px contains declarations and can be included wherever needed.</P> 