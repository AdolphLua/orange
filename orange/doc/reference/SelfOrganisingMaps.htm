<html><HEAD>
<LINK REL=StyleSheet HREF="../style.css" TYPE="text/css" MEDIA=screen>
<LINK REL=StyleSheet HREF="style-print.css" TYPE="text/css" MEDIA=print>
</HEAD> <body>

<h1>Self Organising Maps</h1>

<p>The self-organising map (SOM) is a method for unsupervised learning, based on a grid of artificial neurons whose weights are adapted to match input vectors in a training set.</p>

<h2>SOMLearner</h2>
<p>SOMLearner class constructs an instance of SOMClassifier or if given a classless domain an instance of SOMMap. SOMClassifier is actualy just a SOMMap with a defined call function that returns a majority class at the winning node.</p>

<P class=section>Attributes</P>
<DL class=attributes>
<DT>xDim</DT>
<DD>X dimension of the map (default 10)</DD>
<DT>yDim</DT>
<DD>Y dimension of the map (default 10)</DD>
<DT>topology</DT>
<DD>Topology of the map. Can be a SOMLearner.RetangularTopology for rectangular or SOMLearner.HexagonalTopology (default) for hexagonal topology</DD>
<DT>neighborhood<DT>
<DD>Neighborhood function type. Can be SOMLearner.BubbleNeighborhood (default) or SOMLearner.GaussianNeighborhood</DD>
<DT>steps</DT>
<DD>Number of steps (default 2)</DD>
<DT>alphaType</DT>
<DD>A alpha function type. Can be a SOMLearner.LinearFunction (default) or SOMLearner.InverseFunction</DD>
<DT>alpha<DT>
<DD>A list of alpha values (learning rate) to be used at the beginning of each step (default [0.05,0.03]</DD>
<DT>iterations</DT>
<DD>A list of iterations at each step (default [1000, 10000])</DD>
<DT>radius</DT>
<DD>A list of radius values for neighborhood function at each step (default [10,5])</DD>
<DL>domainContinuizer</DL>
<DD>Domain continuizer used to transform the domain</DD>
<DL>transformedDomain</DL>
<DD>Transformed domain</DD>
</DL>

<h2>SOMMap</h2>
<p>SOMMap holds the resulting 2 dimensional map of SOMNodes</p>
<P class=section>Attributes</P>
<DL class =attributes>
<DT>xDim</DT>
<DD>X dimension of the map</DD>
<DT>yDim</DT>
<DD>Y dimension of the map</DD>
<DT>topology</DT>
<DD>Topology of the map. Can be a SOMLearner.RetangularTopology for rectangular or SOMLearner.HexagonalTopology (default) for hexagonal topology</DD>
<DT>neighborhood<DT>
<DD>Neighborhood function type. Can be SOMLearner.BubbleNeighborhood (default) or SOMLearner.GaussianNeighborhood</DD>
<DT>nodes</DT>
<DD>A list of SOMNodes</DD>
<DL>transformedDomain</DL>
<DD>Transformed domain</DD>
<DT>error</DT>
<DD>Quantiztion error of the map</DD>
</DL>

<P class=section>Methods</P>
<DL class =attributes>
<DT>getWinner(example) ((example)->SOMNode)</DT>
<DD>Returns the node closest to the example</DD>
</DL>

<h2>SOMNode</h2>
<p>SOMNode holds the codebook vector</p>
<P class=section>Attributes</P>
<DL class =attributes>
<DT>vector</DT>
<DD>Holds the codebook vector</DD>
<DT>examples</DT>
<DD>Holds the examples for whitch this is the winning node</DD>
</DT>

<P class =section>Methods</P>
<DL classs =attributes>
<DT>getDistance(example) ((example)->float)</DT>
<DD>Computes the distance to the node</DD>
</DL>

<h2>Examples</h2>
<xmp class=code>
>>>data=orange.ExampleTable("iris")
>>>map=orange.SOMLearner(data)
>>>print map.nodes[0].examples
...
...
>>>print map.nodes[0].vector
...
>>>map.getDistance(data[0])
1.56
</xmp>

</body></html>

