.. py:currentmodule:: Orange.data

=============================
Data instances (``Instance``)
=============================

Class `Orange.data.Instance` holds data instances. Each data instance
corresponds to a domain, which defines its length, data types and
values for symbolic indices.

--------
Features
--------

The data instance is described by a list of features, defined by the
domain descriptor. Instances support indexing with either integer
indices, strings or variable descriptors.

Since "age" is the the first attribute in dataset lenses, the
below statements are equivalent.::

    >>> age = data.domain["age"]
    >>> example = data[0]
    >>> print example[0]
    young
    >>> print example[age]
    young
    >>> print example["age"]
    young

Negative indices do not work as usual in Python, since they return
the values of meta attributes.

The last element of data instance is the class label, if it
exists. It should be accessed using :obj:`get_class` and
:obj:`set_class`.

Data instances can be traversed using a for loop.

The list has a fixed length, determined by the domain to which the
instance corresponds.

---------------
Meta attributes
---------------

Meta attributes provide a way to attach additional information to
examples. These attributes are treated specially, for instance, they
are not used for learning, but can carry additional information, such
as, for example, a name of a patient or the number of times the
instance was missclassified during some test procedure. The most
common additional information is the instance's weight.

For contrast from ordinary features, instances from the same domain do
not need to have the same meta attributes. Meta attributes are hence
not addressed by positions, but by their id's, which are represented
by negative indices. Id's are generated by function
:obj:`Orange.data.variable.new_meta_id()`. Id's can be reused for
multiple domains.

If ordinary features resemble lists, meta attributes can be seen as a
dictionaries.

Domain descriptor can, but doesn't need to know about
meta descriptors. See documentation on :obj:`Orange.data.Domain` for
more on that.

If there is a particular descriptor associated with the meta attribute
for the domain, attribute or its name can also be used for
indexing. When registering meta attributes with domains, it is
recommended to used the same id for the same attribute in all domains.

Meta values can also be loaded from files in tab-delimited format.

Meta attributes are often used as weights. Many procedures, such as
learning algorithms, accept the id of the meta attribute defining the
weights of instances as an additional argument besides the data.

The following example adds a meta attribute with a random value to
each data instance

.. literalinclude:: code/instance-metavar.py
    :lines: 1-

The code prints out something like::

    ['young', 'myope', 'no', 'reduced', 'none'], {-2:0.84}

Data instance now consists of two parts, ordinary features that
resemble a list since they are addressed by positions (eg. the first
value is "psby"), and meta values that are more like dictionaries,
where the id (-2) is a key and 0.34 is a value (of type
:obj:`Orange.data.Value`).

To tell the learning algorithm to use the weights, the id needs to be
passed along with the data::

    bayes = orange.BayesLearner(data, id)

Many other functions accept weights in similar fashion.

Code::

    print orange.getClassDistribution(data)
    print orange.getClassDistribution(data, id)

prints out::

    <15.000, 5.000, 4.000>
    <9.691, 3.232, 1.969>

Registering the meta attribute changes how the data instance is
printed out and how it can be accessed::

    w = orange.FloatVariable("w")
    data.domain.addmeta(id, w)

Meta-attribute can now be indexed just like ordinary features. The
following three statements are equivalent::

    print data[0][id]
    print data[0][w]
    print data[0]["w"]

Another consequence of registering the meta attribute is that it
allows for conversion from Python native types::

    ok = orange.EnumVariable("ok?", values=["no", "yes"])
    ok_id = orange.newmetaid()
    data.domain.addmeta(ok_id, ok)
    data[0][ok_id] = "yes"

The last line fails unless the attribute is registered since Orange
does not know which variable descriptor to use to convert the string
"yes" to an attribute value.

-------
Hashing
-------

Data instances compute hashes using CRC32 and can thus be used for
keys in dictionaries or collected to Python data sets.

.. class:: Instance

    .. attribute:: domain

        The domain to which the data instance corresponds. This
        attribute is read-only.

    .. method:: __init__(domain[, values])

        Construct a data instance with the given domain and initialize
        the values. Values should be given as a list containing
        objects that can be converted into values of corresponding
        variables; generally, they can be given as strings and
        integer indices (for discrete varaibles) or numbers (for
        continuous variables), and also as instances of
        :obj:`Orange.data.Value`.

        If values are omitted, they are set to unknown.

        :param domain: domain descriptor
        :type domain: Orange.data.Domain
        :param values: A list of values
        :type value: list

        The following example loads data on lenses and constructs
        another data instance from the same domain.

        .. literalinclude:: code/instance-construct.py
            :lines: 1-5

        Same can be done using other representations of values

        .. literalinclude:: code/instance-construct.py
            :lines: 7-8

    .. method:: __init__([domain ,] instance)

        Construct a new data instance as a shallow copy of the
        original. If a domain descriptor is given, the instance is
        converted; conversion can add or remove variables, including
        transformations, like discretization ets.

        :param domain: domain descriptor
        :type domain: Orange.data.Domain
        :param instance: Data instance
        :type value: :obj:`Instance`

        The following examples constructs a reduced domain and a data
        instance in this domain. ::

            domain_red = Orange.data.Domain(["age", "lenses"], domain)
            inst_red = Orange.data.Instance(domain_red, inst)

    .. method:: __init__(domain, instances)

        Construct a new data instance for the given domain, where
        attribute values are taken from the provided instances, using
        both their ordinary features and meta attributes, which are
        registered with their corresponding domains. Meta attributes
        which appear in the provided instances and do not appear in
        the domain of the new instance, are copied as well.

        :param domain: domain descriptor
        :type domain: Orange.data.domain
        :param instances: data instances
        :type value: list of Orange.data.Instance

        .. literalinclude:: code/instance_merge.py
                :lines: 3-

        The new domain consists of variables from `data1` and `data2`:
        `a1`, `a3` and `m1` are ordinary features, and `m2` and `a2`
        are meta attributes in the new domain. `m2` has the
        same meta attribute id as it has in `data1`, while `a2` gets a
        new meta id. In addition, the new domain has two new
        attributes, `n1` and `n2`.

        Here is the output::

            First example:  [1, 2], {"m1":3, "m2":4}
            Second example:  [1, 2.5], {"m1":3, "m3":4.5}
            Merge:  [1, 2.5, 3, ?], {"a2":2, "m2":4, -5:4.50, "n2":?}


        Since attributes `a1` and `m1` appear in domains of both
        original instance, the new instance can only be constructed if
        these values match. `a3` comes from the second instance, and
        meta attributes `a2` and `m1` come from the first one. The
        meta attribute `m3` is also copied from the second instance;
        since it is not registered within the new domain, it is
        printed out with an id (-5) instead of with a name. Values of
        the two new attributes are left undefined.

    .. method:: native([level])

        Converts the instance into an ordinary Python list. If the
        optional argument is 1 (default), the result is a list of
        objects of :obj:`orange.Data.value`. If it is 0, it contains
        pure Pyhon objects, that is, strings for discrete variables
        and numbers for continuous ones.

    .. method:: compatible(other, ignore_class=0)

        Return :obj:`True` if the two instances are compatible, that
        is, equal in all features which are not missing in one of
        them. The optional second argument can be used to omit the
        class from comparison.

    .. method:: get_class()

        Return the instance's class as :obj:`Orange.data.Value`.

    .. method:: get_classes()

        Return the values of multiple classes as a list of
        :obj:`Orange.data.Value`.

    .. method:: set_class(value)

        Set the instance's class.

        :param value: the new instance's class
        :type value: :obj:`Orange.data.Value`, number or string

    .. method:: set_classes(values)

        Set the values of multiple classes.

        :param values: a list of values; the length must match the number of multiple classes
        :type values: list

    .. method:: get_metas([key_type])

        Return a dictionary containing meta values of the data
        instance. The key type can be :obj:`int` (default), :obj:`str`
        or :obj:`Orange.data.variable.Variable` and determines whether
        the dictionary keys will be meta ids, variables names or
        variable descriptors. In the latter two cases, only registered
        attributes are returned. ::

            data = orange.ExampleTable("inquisition2")
            example = data[4]
            print example.getmetas()
            print example.getmetas(int)
            print example.getmetas(str)
            print example.getmetas(orange.Variable)

        :param key_type: the key type; either :obj:`int`, :obj:`str` or :obj:`Orange.data.variable.Variable`
        :type key_type: :obj:`type`

    .. method:: get_metas(optional, [key_type])

        Similar to above, but return a dictionary containing meta
        values of the data instance which are or which are not
        optional.

        :param optional: tells whether to return optional or non-optional attributes
        :type optional: :obj:`bool`
        :param key_type: the key type; either :obj:`int`, :obj:`str` or :obj:`Orange.data.variable.Variable`
        :type key_type: :obj:`type`

    .. method:: has_meta(meta_attr)

        Return :obj:`True` if the data instance has the specified meta
        attribute, specified by id, string or descriptor.

        :param meta_attr: meta attribute
        :type meta_attr: :obj:`id`, :obj:`str` or :obj:`Orange.data.variable.Variable`

    .. method:: remove_meta(meta_attr)

        Remove meta attribute.

        :param meta_attr: meta attribute
        :type meta_attr: :obj:`id`, :obj:`str` or :obj:`Orange.data.variable.Variable`

    .. method:: get_weight(meta_attr)

        Return the value of the specified meta attribute. The value
        must be continuous; it is returned as a :obj:`float`.

        :param meta_attr: meta attribute
        :type meta_attr: :obj:`id`, :obj:`str` or :obj:`Orange.data.variable.Variable`

    .. method:: set_weight(meta_attr, weight=1)

        Set the value of the specified meta attribute to `weight`. The value
        must be continuous; it is returned as a :obj:`float`.

        :param meta_attr: meta attribute
        :type meta_attr: :obj:`id`, :obj:`str` or :obj:`Orange.data.variable.Variable`
        :param weight: weight of the instance
        :type weight: :obj:`float`
